
<!DOCTYPE html>

<html>

<head>
  <title>kaboom</title>
  <meta charset="utf-8">
  <style>
    * {
      margin: 0;
    }
    html,
    body {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>

<body>
<script src="https://kaboomjs.com/lib/master/kaboom.js"></script>
<script src="https://kaboomjs.com/lib/master/kit/physics.js"></script>
<script src="https://kaboomjs.com/lib/master/kit/starter.js"></script>
<script src="https://kaboomjs.com/lib/master/kit/level.js"></script>

  <script>kaboom.import();</script>
  <script>
loadSprite("boss01", "sprites/boss01.png");
loadSprite("bullet00", "sprites/bullet00.png");
loadSprite("eb1", "sprites/eb1.png");
loadSprite("eb2", "sprites/eb2.png");
loadSprite("enemy00", "sprites/enemy00.png");
loadSprite("enemy01", "sprites/enemy01.png");
loadSprite("hitpoint", "sprites/hitpoint.png");
loadSprite("player00", "sprites/player00.png");
loadSprite("player01", "sprites/player01.png");
loadSprite("point", "sprites/point.png");
loadSprite("power", "sprites/power.png");
loadSprite("title00", "sprites/title00.jpg");
loadSound("bossDestroy", "sounds/bossDestroy.wav");
loadSound("fire", "sounds/fire.wav");
loadSound("hit", "sounds/hit.mp3");
loadSound("kill", "sounds/kill.wav");
loadSound("pick", "sounds/pick.wav");
loadSound("th06_01", "sounds/th06_01.mp3");
loadSound("th06_02", "sounds/th06_02.mp3");

init({
  width: false ? window.innerWidth / 1 : 640,
  height: false ? window.innerHeight / 1 : 480,
  scale: 1,
});
scene("gameover", (args = {}) => {
    add([
      pos(width() / 2, height() / 2),
      text("Game Over\nPress Enter to return")
    ]);

    keyPress("enter", () => {
      go("main", {});
    })
});
scene("level1", (args = {}) => {
	const BULLET_SPEED = 800;
  const ENEMY_BULLET_SPEED = 100;
	const ENEMY_SPEED = 100;
	const PLAYER_SPEED = 200;
  const INITIAL_POWERUP_POINT_SPEED = -60;
  const INITIAL_POWERUP_POWER_SPEED = -50;

  let isFiring = false;
  let power = 1;
  let position = 0;
  let life = 3;
  let isRespawning = false;
  let isInvincible = false;
  let isFocusing = false;
  let isBossExist = false;

  gravity(200);

  var bgm = document.getElementById("bgm");

  bgm.ontimeupdate = function () {
    if (bgm.currentTime >= vid.duration - 0.2) {
      bgm.currentTime = 21;
      bgm.play();
    }
  }

  function mapWidth() {
    return width() / 3 * 2;
  }

  const MAX_BOSS_HP_BAR_WIDTH = mapWidth() - 50;

  function getDirection(ex, ey) {
    var dx = player.pos.x - ex;
    var dy = player.pos.y - ey;
    var r = Math.hypot(player.pos.x - ex, player.pos.y - ey);
    if (dx <= 0 && dy >= 0) return Math.asin(Math.abs(dy) / r);
    if (dx >= 0 && dy >= 0) return Math.PI - Math.asin(Math.abs(dy) / r);
    if (dx >= 0 && dy <= 0) return Math.asin(Math.abs(dy) / r) + Math.PI;
    if (dx <= 0 && dy <= 0) return Math.PI * 2 - Math.asin(Math.abs(dy) / r);
  }

  const enemyALocation = [ 9, 12, 13, 14, 22, 23, 24, 
                         109, 112, 113, 114, 122, 123, 124,
                         209, 212, 213, 214, 222, 223, 224];
  const enemyBLocation = [32, 34, 36, 38, 40, 52, 54, 56, 58, 60,
                       132, 134, 136, 138, 140, 152, 154, 156, 158, 160,
                       232, 234, 236, 238, 240, 252, 254, 256, 258, 260];
  const enemyCLocation = [31, 33, 35, 37, 39, 51, 53, 55, 57, 59,
                      131, 133, 135, 137, 139, 151, 153, 155, 157, 159,
                      231, 233, 235, 237, 239, 251, 253, 255, 257, 259];
  const enemyDLocation = [72, 74, 76, 78, 80, 92, 94, 96, 98, 100,
                          172, 174, 176, 178, 180, 192, 194, 196, 198, 200,
                          272, 274, 276, 278, 280, 292, 294, 296, 298, 300];

  const boss1Location = [301];
  
  // play("th06_02");

	let player = add([
		sprite("player01"),
		pos(mapWidth() / 2, height() - 15),
		scale(1),
    "player"
	]);

  let playerHitJudgePoint = add([
    sprite("hitpoint"),
    pos(player.pos.x, player.pos.y),
    scale(0.7),
    "playerHitJudgePoint"
  ]);

  let bossHPBar = add([
    rect(MAX_BOSS_HP_BAR_WIDTH, 10),
    pos(5, 10),
    color(1,1,1),
    origin("left")
  ]);

  bossHPBar.hidden = true;

	keyDown("left", () => {
    if (player.pos.x > 0) {
		  player.move(-PLAYER_SPEED * (isFocusing ? 0.5 : 1), 0);
    } else {
      player.pos.x = 0;
    }
	});

	keyDown("right", () => {
    if (player.pos.x < mapWidth()) {
		  player.move(PLAYER_SPEED * (isFocusing ? 0.5 : 1), 0);
    } else {
      player.pos.x = mapWidth();
    }
	});

  keyDown("up", () => {
    if (player.pos.y > 0) {
		  player.move(0, -PLAYER_SPEED * (isFocusing ? 0.5 : 1));
    } else {
      player.pos.y = 0;
    }
	});

  keyDown("down", () => {
    if (player.pos.y < height()) {
		  player.move(0, PLAYER_SPEED * (isFocusing ? 0.5 : 1));
    } else {
      player.pos.y = height();
    }
	});

  keyDown("z", () => { isFiring = true; });

  keyRelease("z", () => { isFiring = false; });

  keyDown("shift", () => { isFocusing = true;});

  keyRelease("shift", () => { isFocusing = false;}); // shift key has issues

/*
	keyPress("space", () => {
		add([
			sprite("bullet00"),
			pos(player.pos),
			// strings here means a tag
			"bullet",
		]);
	});
*/
	// run this callback every frame for all objects with tag "bullet"
	action("bullet", (b) => {
		b.move(Math.cos(b.direction) * BULLET_SPEED, -Math.sin(b.direction) * BULLET_SPEED);
		// remove the bullet if it's out of the scene for performance
		if (b.pos.y < 0 || b.pos.x < 0 || b.pos.x > mapWidth()) {
			destroy(b);
		}
	});

	function spawnEnemyA() { return add([	sprite("enemy00"),	pos(rand(0, mapWidth()), 0), "enemyA", {
    time: 0
  }]);}
  function spawnEnemyB() { return add([	sprite("enemy00"),	pos(0, 48), "enemyB", {
    time: 0
  }]);}
  function spawnEnemyC() { return add([	sprite("enemy00"),	pos(mapWidth(), 48), "enemyC", {
    time: 0
  }]);}
  function spawnEnemyD() { return add([	sprite("enemy01"),	pos(rand(0, mapWidth()), 0), "enemyD", {
    time: 0
  }]);}

  function spawnBoss1() {
    isBossExist = true;
    bossHPBar.hidden = false;
    bossHPBar.width = MAX_BOSS_HP_BAR_WIDTH;
    return add([
      sprite("boss01"),
      pos(mapWidth() / 2, 0),
      "boss01", {
        time: 0,
        life: 200,
        maxLife: 200,
        countdown: 60,
        downspeed: 1,
        isLanding: true,
        damaku: [
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 2, speed: 100, begin: 111},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 4, speed: 100, begin: 111},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 6, speed: 100, begin: 111},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 8, speed: 100, begin: 111},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 10, speed: 100, begin: 111},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 12, speed: 100, begin: 111},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 14, speed: 100, begin: 111},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 16, speed: 100, begin: 111},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 18, speed: 100, begin: 111},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 20, speed: 100, begin: 111},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 22, speed: 100, begin: 111},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 24, speed: 100, begin: 111},

          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 1, speed: 100, begin: 101},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 3, speed: 100, begin: 101},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 5, speed: 100, begin: 101},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 7, speed: 100, begin: 101},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 9, speed: 100, begin: 101},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 11, speed: 100, begin: 101},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 13, speed: 100, begin: 101},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 15, speed: 100, begin: 101},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 17, speed: 100, begin: 101},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 19, speed: 100, begin: 101},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 21, speed: 100, begin: 101},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 23, speed: 100, begin: 101},

          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 1, speed: 100, begin: 121},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 3, speed: 100, begin: 121},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 5, speed: 100, begin: 121},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 7, speed: 100, begin: 121},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 9, speed: 100, begin: 121},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 11, speed: 100, begin: 121},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 13, speed: 100, begin: 121},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 15, speed: 100, begin: 121},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 17, speed: 100, begin: 121},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 19, speed: 100, begin: 121},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 21, speed: 100, begin: 121},
          {sprite: "eb1", interval: 100, direction: Math.PI / 12 * 23, speed: 100, begin: 121},
        ]
      }
    ])
  }

  action("boss01", (e) => {
    if (e.pos.y < 80 && e.isLanding) {
      e.pos.y += e.downspeed;
      return;
    } else {
      e.isLanding = false;
    }
    e.time++;

    e.pos.x = mapWidth() / 2 + Math.cos(e.time / 100 + Math.PI / 2) * 100;
    e.pos.y = 60 + Math.sin(e.time / 100 + Math.PI / 2) * 20;
    
    for (var x in e.damaku) {
      if ((e.time - e.damaku[x].begin) % e.damaku[x].interval == 0) {
        add([	sprite(e.damaku[x].sprite),	pos(e.pos.x, e.pos.y), "bossBullet1", {
          direction: e.damaku[x].direction,
          speed: e.damaku[x].speed
        }]);
      }
    }
    
  });

  collides("bullet", "boss01", (bullet, boss) => {
    boss.life--;
    destroy(bullet);
    bossHPBar.width = MAX_BOSS_HP_BAR_WIDTH * boss.life / boss.maxLife;
    if (boss.life <= 0) {
      play("bossDestroy", {volume : 0.7});
      destroy(boss);
      bossHPBar.hidden = true;
      isBossExist = false;
    }
  });

  const hudBorder = add([
    // width, height
    rect(209, 470),
    pos(533, 240),
    color(1, 1, 1),
  ]);

  const hud = add([
    // width, height
    rect(207, 468),
    pos(533, 240),
    color(0, 0, 0),
  ]);

	const score = add([
		pos(width() - 200, 12),
		text("Score   0"),
		// all objects defaults origin to center, we want score text to be top left
		origin("topleft"),
		// plain objects becomes fields of score
		{
			value: 0,
		},
	]);

  const powerText = add([
    pos(width() - 200, 20),
    text("Power   1.0"),
    origin("topleft"),
    {}
  ])

  const lifeText = add([
    pos(width() - 200, 28),
    text("Player  " + life),
    origin("topleft"),
    {}
  ])

  function defeatAnEnemy(b, e) {
    play("kill", {volume: 0.3});
		destroy(b);
		destroy(e);
		score.value += 1;
		score.text = "Score   " + score.value;

    let rand = Math.random();
    if (rand > 0.6) {
      add([
        sprite("point"),
        pos(e.pos),
        body(),
        // strings here means a tag
        "powerup-point",
      ]);
    }

    if (rand > 0.1 && rand <= 0.4) {
      add([
        sprite("power"),
        pos(e.pos),
        body(),
        // strings here means a tag
        "powerup-power",
      ]);
    }
  }

	// if a "bullet" and a "enemy" collides, remove both of them
	collides("bullet", "enemyA", (b, e) => { defeatAnEnemy(b, e); });
  collides("bullet", "enemyB", (b, e) => { defeatAnEnemy(b, e); });
  collides("bullet", "enemyC", (b, e) => { defeatAnEnemy(b, e); });
  collides("bullet", "enemyD", (b, e) => { defeatAnEnemy(b, e); });


  collides("player", "powerup-point", (p, pp) => {
    if (isRespawning) { return; }
    play("pick", {volume: 0.5});
    let getScore = parseInt(100 + height() - p.pos.y);
    if (getScore > 800) {
      getScore = 800;
    }
    score.value += getScore;
    score.text = "Score   " + score.value;
    destroy(pp);
  });

  collides("player", "powerup-power", (p, pp) => {
    if (isRespawning) { return; }
    play("pick", {volume: 0.5});
    if (power < 10) {
      //power+=2.3;
      power+=0.3;
      powerText.text = "Power   " + power.toFixed(1);
      if (power > 10) {
        power = 10;
        powerText.text = "Power   MAX";
      }
      
    }
    destroy(pp);
  });

  function playerHit(p, e) {
    if (isInvincible || isRespawning) { return; }
    isRespawning = true;
    play("hit");
    life--;
    power--;
    if (power < 1) { power = 1; }
    lifeText.text = "Player  " + life;
    powerText.text = "Power   " + power.toFixed(1);
    if (life < 0) {
      bgm.pause();
      go("gameover", score);
      return;
    }
    destroy(e);
    p.hidden = true;
    player.hidden = true;
    wait(2, () => {
      player.pos.x = mapWidth() / 2;
      player.pos.y = height() - 15;
      p.hidden = false;
      player.hidden = false;
      isRespawning = false;
      isInvincible = true;
      wait(3, () => {
        isInvincible = false;
      });
    });
  }

  collides("playerHitJudgePoint", "enemyBullet1", (e, eb) => { playerHit(e, eb); });
  collides("playerHitJudgePoint", "enemyBullet2", (e, eb) => { playerHit(e, eb); });
  collides("playerHitJudgePoint", "bossBullet1", (e, eb) => { playerHit(e, eb); });
  collides("playerHitJudgePoint", "enemyA", (e, eb) => { playerHit(e, eb); });
  collides("playerHitJudgePoint", "enemyB", (e, eb) => { playerHit(e, eb); });
  collides("playerHitJudgePoint", "enemyC", (e, eb) => { playerHit(e, eb); });
  collides("playerHitJudgePoint", "enemyD", (e, eb) => { playerHit(e, eb); });
  

	action("enemyA", (e) => {
		e.move(0, ENEMY_SPEED);
    e.time++;
    if (e.time == 50) { // enemy shoot
      add([	
        sprite("eb2"), 
        rotate(getDirection(e.pos.x, e.pos.y) + Math.PI / 2) , 
        pos(e.pos.x, e.pos.y), 
        "enemyBullet2", {
          direction: getDirection(e.pos.x, e.pos.y)
        }
      ]);
    }
		if (e.pos.y > height()) {
			destroy(e);
		}
	});

  action("enemyB", (e) => {
		e.move(ENEMY_SPEED, 0);
    e.time++;
    if (e.time == 50) { // enemy shoot
      add([	
        sprite("eb2"), 
        rotate(getDirection(e.pos.x, e.pos.y) + Math.PI / 2) , 
        pos(e.pos.x, e.pos.y), 
        "enemyBullet2", {
          direction: getDirection(e.pos.x, e.pos.y)
        }
      ]);
    }
		if (e.pos.x > mapWidth()) {
			destroy(e);
		}
	});

  action("enemyC", (e) => {
    e.time++;
		e.move(-ENEMY_SPEED, 0);
    if (e.time == 50) { // enemy shoot
      add([	
        sprite("eb2"), 
        rotate(getDirection(e.pos.x, e.pos.y) + Math.PI / 2) , 
        pos(e.pos.x, e.pos.y), 
        "enemyBullet2", {
          direction: getDirection(e.pos.x, e.pos.y)
        }
      ]);
    }
		if (e.pos.x < 0) {
			destroy(e);
		}
	});

  action("enemyD", (e) => {
		e.move(0, ENEMY_SPEED);
    e.time++;
    if (e.time % 100 == 0) { // enemy shoot
      let randDirection = rand(0, Math.PI * 2);
      for (let i = 0; i < 6; i ++) {
        add([	sprite("eb1"),	pos(e.pos.x, e.pos.y), "enemyBullet1", {
          direction: randDirection + ((Math.PI / 3) * i)
        }]);
      }
    }
		if (e.pos.y > height()) {
			destroy(e);
		}
	});

  action("powerup-point", (pp) => {
    let currentSpeed = INITIAL_POWERUP_POINT_SPEED;
    pp.move(0, currentSpeed++);
    if (pp.pos > height()) {
      destroy(pp);
    }
  });

  action("powerup-power", (pp) => {
    let currentSpeed = INITIAL_POWERUP_POWER_SPEED;
    pp.move(0, currentSpeed++);
    if (pp.pos > height()) {
      destroy(pp);
    }
  });

  action("enemyBullet1", (eb) => {
    let currentSpeed = ENEMY_BULLET_SPEED;
    eb.move(Math.cos(eb.direction) * currentSpeed, Math.sin(eb.direction) * currentSpeed);
    if (eb.pos.x < 0 || eb.pos.x > mapWidth() || eb.pos.y < 0 || eb.pos.y > height()) {
      destroy(eb);
    }
  });

  action("enemyBullet2", (eb) => {
    let currentSpeed = ENEMY_BULLET_SPEED;
    eb.move(Math.cos(eb.direction) * currentSpeed * -1, Math.sin(eb.direction) * currentSpeed);
    if (eb.pos.x < 0 || eb.pos.x > mapWidth() || eb.pos.y < 0 || eb.pos.y > height()) {
      destroy(eb);
    }
  });

  action("bossBullet1", (eb) => {
    let currentSpeed = eb.speed;
    eb.move(Math.cos(eb.direction) * currentSpeed, Math.sin(eb.direction) * currentSpeed);
    if (eb.pos.x < 0 || eb.pos.x > mapWidth() || eb.pos.y < 0 || eb.pos.y > height()) {
      destroy(eb);
    }
  });

  action("player", (p) => {
    playerHitJudgePoint.pos.x = p.pos.x + 2;
    playerHitJudgePoint.pos.y = p.pos.y - 2;
  });

	// spawn an enemy every 1 second
	loop(0.3, () => {
    if (!isBossExist) {
      position++;
    }
    if (boss1Location.lastIndexOf(position) != -1 && !isBossExist) spawnBoss1();
    if (enemyALocation.lastIndexOf(position) != -1) spawnEnemyA();
    if (enemyBLocation.lastIndexOf(position) != -1) spawnEnemyB();
    if (enemyCLocation.lastIndexOf(position) != -1) spawnEnemyC();
    if (enemyDLocation.lastIndexOf(position) != -1) spawnEnemyD();
  });

  loop(0.05, () => {
    if (isFiring && !isRespawning) {
      play("fire", {volume: 0.3});
      // console.log(isFocusing);
      for (let i = 0; i < parseInt(power); i++) {
        add([
          sprite("bullet00"),
          pos(player.pos),
          // strings here means a tag
          "bullet",
          {
            direction: Math.PI / 2 + ((isFocusing ? 0.03 : 0.07) * parseInt(i + 1 / 2) * Math.pow(-1, i))
          }
        ]);
      }
    } 
  });
});
scene("main", (args = {}) => {
    add([
      sprite("title00"),
      scale(width() / 640, height() / 480),
		  origin("topleft"),
    ]);

    // play("th06_01");
    var bgm = document.getElementById("bgm");

    if (bgm == undefined) {
      bgm = document.createElement("audio");
      bgm.id = "bgm";
      bgm.loop = true;
    }

    bgm.src = "./sounds/th06_01.mp3";
    if (document.getElementById("bgm") == undefined) {
      document.body.appendChild(bgm);
    }
    bgm.play();
    
    add([
      pos(width() / 2, 40),
      text("Touhou Akamakyou", 32),
      color(1, 0, 0)
    ]);

    add([
      pos(width() / 2, 80),
      text("V3.1"),
      color(1, 0, 0)
    ]);

    add([
      pos(width() / 2, height() / 2 + 120),
      text("Enter: Start")
    ]);

    add([
      pos(width() / 2, height() / 2 + 130),
      text("Arrow Keys (Hold): Move")
    ]);

    add([
      pos(width() / 2, height() / 2 + 140),
      text("Z (Hold): Fire")
    ]);

    add([
      pos(width() / 2, height() / 2 + 150),
      text("X: Bomb")
    ]);

    add([
      pos(width() / 2, height() / 2 + 160),
      text("Shift (Hold): Slow down and concentrate fire")
    ]);

    add([
      pos(width() / 2, height() / 2 + 170),
      text("(c) 2021 No.5972 . MIT License.")
    ]);

    add([
      pos(width() / 2, height() / 2 + 185),
      text("This project is of 2ndary creation based on Touhou Koumakyou. \nCopyright of the material belongs to the original author.")
    ]);

    keyPress("enter", () => {
      bgm.pause();
      bgm.src = "./sounds/th06_02.mp3";
      bgm.load();
      bgm.play();
      go("level1", {});
    })
});
start("main");

  </script>
</body>

</html>
